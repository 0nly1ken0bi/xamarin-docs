<table width="100%" border="1px">
<tr>
    <td><b>Property</b></td>
    <td><b>Description</b></td>
    <td><b>Options</b></td>
</tr>
<tr>
    <td><code> abi.type </code></td>
    <td><strong>ABI type</strong> &ndash; Specifies the ABI (application binary interface) type of the emulated device. The <code>x86</code> option is for the instruction set commonly referred to as "x86" or "IA-32." The <code>x86_64</code> option is for the 64-bit x86 instruction set. The <code>armeabi-v7a</code> option is for the ARM instruction set with v7-a ARM extensions. The <code>arm64-v8a</code> option is for the ARM instruction set that supports AArch64.  </td>
    <td> x86, x86_64, armeabi-v7a, arm64-v8a </td>
</tr>
<tr>
    <td><code> disk.cachePartition </code></td>
    <td><strong>Cache partition</strong> &ndash; Determines whether the emulated device will use a <strong>/cache</strong> partition on the device. The <strong>/cache</strong> partition (which is initially empty) is the location where Android stores frequently accessed data and app components. If set to <code>no</code>, the emulator will not use a <strong>/cache</strong> partition and the other <code>disk.cache</code> settings will be ignored.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code> disk.cachePartition.path </code></td>
    <td><strong>Cache partition path</strong> &ndash; Specifies a cache partition image file on your development computer. The emulator will use this file for the <strong>/cache</strong> partition. Enter an absolute path or a path relative to the emulator's <strong>data</strong> directory. If not set, the emulator creates an empty temporary file called <strong>cache.img</strong> on your development computer. If the file does not exist, it is created as an empty file. This option is ignored if <code>disk.cachePartition</code> is set to <code>no</code>. </td>
    <td>  </td>
</tr>
<tr>
    <td><code> disk.cachePartition.size </code></td>
    <td><strong>Cache partition size</strong> &ndash; The size of the cache partition file (in megabytes). Normally you do not need to set this option unless the app will be downloading very large files that are larger than the default cache size of 66 megabytes. This option is ignored if <code>disk.cachePartition</code> is set to <code>no</code>.</td>
    <td>  </td>
</tr>
<tr>
    <td><code> disk.dataPartition.initPath </code></td>
    <td><strong>Initial path to the data partition</strong> &ndash; Specifies the initial contents of the data partition. After wiping user data, the emulator copies the contents of the specified file to user data (by default, <strong>userdata-qemu.img</strong>) instead of using <strong>userdata.img</strong> as the initial version. </td>
    <td>  </td>
</tr>
<tr>
    <td><code> disk.dataPartition.path </code></td>
    <td><strong>Path to the data partition</strong> &ndash; Specifies the user data partition file. To configure a persistent user data file, enter a filename and a path on your development computer. If the file doesn't exist, the emulator creates an image from the default file <strong>userdata.img</strong>, stores it in the filename specified by <code>disk.dataPartition.path</code>, and persists user data to it when the emulator shuts down. If you don't specify a path, the default file is named <strong>userdata-qemu.img</strong>. The special value <code>&lt;temp&gt;</code> causes the emulator to create and use a temporary file. If <code>disk.dataPartition.initPath</code> is set, its content will be copied to the <code>disk.dataPartition.path</code> file at boot-time. Note that this option cannot be left blank.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> disk.dataPartition.size </code></td>
    <td><strong>Data partition size</strong> &ndash; Specifies the size of the user data partition in megabytes.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> disk.ramdisk.path </code></td>
    <td><strong>Ramdisk path</strong> &ndash; Path to the boot partition (ramdisk) image. The ramdisk image is a subset of the system image that is loaded by the kernel before the system image is mounted. The ramdisk image typically contains boot-time binaries and initialization scripts. If this option is not specified, the default is <strong>ramdisk.img</strong> in the emulator system directory.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> disk.snapStorage.path </code></td>
    <td><strong>Snapshot storage path</strong> &ndash; Path to the <i>snapshot storage file</i> where all snapshots are stored. All snapshots made during execution will be saved to this file. Only snapshots that are saved to this file can be restored during the emulator run. If this option is not specified, the default is <strong>snapshots.img</strong> in the emulator data directory.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> disk.systemPartition.initPath </code></td>
    <td><strong>System partition init path</strong> &ndash; Path to the read-only copy of the system image file; specifically, the partition containing the system libraries and data corresponding to the API level and any variant. If this path is not specified, the default is <strong>system.img</strong> in the emulator system directory.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> disk.systemPartition.path </code></td>
    <td><strong>System partition path</strong> &ndash; Path to the read/write system partition image. If this path is not set, a temporary file will be created and initialized from the contents of the file specified by <code>disk.systemPartition.initPath</code>. </td>
    <td>  </td>
</tr>
<tr>
    <td><code> disk.systemPartition.size </code></td>
    <td><strong>System partition size</strong> &ndash; The ideal size of the system partition (in megabytes). The size is ignored if the actual system partition image is larger than this setting; otherwise, it specifies the maximum size that the system partition file can grow to.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> hw.accelerometer </code></td>
    <td><strong>Accelerometer</strong> &ndash; Determines whether the emulated device contains an accelerometer sensor. The accelerometer helps the device determine orientation (used for auto-rotation). The accelerometer reports the acceleration of the device along three sensor axes.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code> hw.audioInput </code></td>
    <td><strong>Audio recording support</strong> &ndash; Determines whether the emulated device can record audio.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code> hw.audioOutput </code></td>
    <td><strong>Audio playback support</strong> &ndash; Determines whether the emulated device can play audio.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code> hw.battery </code></td>
    <td><strong>Battery support</strong> &ndash; Determines whether the emulated device can run on a battery.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code> hw.camera </code></td>
    <td><strong>Camera support</strong> &ndash; Determines whether the emulated device has a camera.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code> hw.camera.back </code></td>
    <td><strong>Back-facing camera</strong> &ndash; Configures the back-facing camera (the lens faces away from the user). If you are using a webcam on your development computer to simulate the back-facing camera on the emulated device, this value must be set to <code>webcam<i>n</i></code>, where <i>n</i> selects the webcam (if you have only one webcam, choose <code>webcam0</code>). If set to <code>emulated</code>, the emulator simulates the camera in software. To disable the back-facing camera, set this value to <code>none</code>. If you enable the back-facing camera, be sure to also enable <code>hw.camera</code>.  </td>
    <td> emulated, none, webcam0 </td>
</tr>
<tr>
    <td><code> hw.camera.front </code></td>
    <td><strong>Front-facing camera</strong> &ndash; Configures the front-facing camera (the lens faces towards the user). If you are using a webcam on your development computer to simulate the front-facing camera on the emulated device, this value must be set to <code>webcam<i>n</i></code>, where <i>n</i> selects the webcam (if you have only one webcam, choose <code>webcam0</code>). If set to <code>emulated</code>, the emulator simulates a camera in software. To disable the front-facing camera, set this value to <code>none</code>. If you enable the front-facing camera, be sure to also enable <code>hw.camera</code>.  </td>
    <td> emulated, none, webcam0 </td>
</tr>
<tr>
    <td><code> hw.camera.maxHorizontalPixels </code></td>
    <td><strong>Maximum horizontal camera pixels</strong> &ndash; Configures the maximum horizontal resolution of the emulated device's camera (in pixels).  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> hw.camera.maxVerticalPixels </code></td>
    <td><strong>Maximum vertical camera pixels</strong> &ndash; Configures the maximum vertical resolution of the emulated device's camera (in pixels).  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> hw.cpu.arch </code></td>
    <td><strong>CPU architecture</strong> &ndash; The CPU architecture to be emulated by the virtual device. If you are using Intel HAXM for hardware acceleration, select <code>x86</code> for a 32-bit CPU. Select <code>x86_64</code> for a 64-bit HAXM-accelerated device. (Be sure to install the corresponding Intel x86 system image in the SDK Manager: for example, <strong>Intel x86 Atom</strong> or <strong>Intel x86 Atom_64</strong>.) To simulate an ARM CPU, select <code>arm</code> for 32-bit or select <code>arm64</code> for a 64-bit ARM CPU. Keep in mind that ARM-based virtual devices will run much slower than those that are x86-based because hardware acceleration is not available for ARM.  </td>
    <td> x86, x86_64, arm, arm64 </td>
</tr>
<tr>
    <td><code> hw.cpu.model </code></td>
    <td><strong>CPU model</strong> &ndash; This value is normally left unset (it will be set to a value that is derived from <code>hw.cpu.arch</code> if it is not explicitly set). However, it can be set to an emulator-specific string for experimental use.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> hw.dPad </code></td>
    <td><strong>DPad keys</strong> &ndash; Determines whether the emulated device supports directional pad (DPad) keys. A DPad typically has four keys to indicate directional control.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code> hw.gps </code></td>
    <td><strong>GPS support</strong> &ndash; Determines whether the emulated device has a GPS (Global Positioning System) receiver.  </td>
    <td> yes, no </td>
<tr>
</tr>
<tr>
    <td><code> hw.gpu.enabled </code></td>
    <td><strong>GPU emulation</strong> &ndash; Determines whether the emulated device supports GPU emulation. When enabled, GPU emulation uses Open GL for Embedded Systems (OpenGL ES) for rendering both 2D and 3D graphics on the screen, and the associated GPU Emulation Mode setting determines how the GPU emulation is implemented.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code> hw.gpu.mode </code></td>
    <td><strong>GPU emulation mode</strong> &ndash; Determines how GPU emulation is implemented by the emulator. If you select <code>auto</code>, the emulator will choose hardware and software acceleration based on your development computer setup. If you select <code>host</code>, the emulator will use your development computer's graphics processor to perform GPU emulation for faster rendering. If your GPU is not compatible with the emulator and you are on Windows, you can try <code>angle</code> instead of <code>host</code>. The <code>angle</code> mode uses DirectX to provide performance similar to <code>host</code>. If you select <code>mesa</code>, the emulator will use the Mesa 3D software library to render graphics. Select <code>mesa</code> if you have problems rendering via your development computer's graphics processor. The <code>swiftshader</code> mode can be used to render graphics in software with slightly less performance than using your computer's GPU. The <code>off</code> option (disable graphics hardware emulation) is a deprecated option that can cause improper rendering for some items and is therefore not recommended. </td>
    <td> auto, host, mesa, angle, swiftshader, off </td>
</tr>
<tr>
    <td><code> hw.gsmModem </code></td>
    <td><strong>GSM modem support</strong> &ndash; Determines whether the emulated device includes a modem that supports the GSM (Global System for Mobile Communications) telephony radio system.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code> hw.initialOrientation </code></td>
    <td><strong>Initial screen orientation</strong> &ndash; Configures the initial orientation of the screen on the emulated device (portrait or landscape mode). In portrait mode, the screen is taller than it is wide. In landscape mode, the screen is wider than it is tall. When running the emulated device, you can change the orientation if both portrait and landscape are supported in the device profile.  </td>
    <td> portrait, landscape </td>
</tr>
<tr>
    <td><code> hw.keyboard </code></td>
    <td><strong>Keyboard support</strong> &ndash; Determines whether the emulated device supports a QWERTY keyboard.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code> hw.keyboard.charmap </code></td>
    <td><strong>Keyboard charmap name</strong> &ndash; The name of the hardware charmap for this device. NOTE: This should always be the default <code>qwerty2</code> unless you have modified the system image accordingly. This name is sent to the kernel at boot time. Using an incorrect name will result in an unusable virtual device.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> hw.keyboard.lid </code></td>
    <td><strong>Keyboard lid support</strong> &ndash; If keyboard support is enabled, this setting determines whether the QWERTY keyboard can be closed/hidden or opened/visible. This setting will be ignored if <code>hw.keyboard</code> is set to <code>false</code>. NOTE: the default value is <code>false</code> if the emulated device targets API level 12 or higher.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code> hw.lcd.backlight </code></td>
    <td><strong>LCD backlight</strong> &ndash; Determines whether an LCD backlight is simulated by the emulated device.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code> hw.lcd.density </code></td>
    <td><strong>LCD density</strong> &ndash; The density of the emulated LCD display, measured in density-independent pixels, or <i>dp</i> (dp is a virtual pixel unit). When the setting is 160 dp, each dp corresponds to one physical pixel. At runtime, Android uses this value to select and scale the appropriate resources/assets for correct display rendering.  </td>
    <td> 120, 160, 240, 213, 320 </td>
</tr>
<tr>
    <td><code> hw.lcd.depth </code></td>
    <td><strong>LCD color depth</strong> &ndash; The color bit-depth of the emulated framebuffer that holds the bitmap for driving the LCD display. This value can be 16 bits (65,536 possible colors) or 32 bits (16,777,216 colors plus transparency). The 32-bit setting can make the emulator run slightly slower but with better color accuracy.  </td>
    <td> 16, 32 </td>
</tr>
<tr>
    <td><code> hw.lcd.height </code></td>
    <td><strong>LCD pixel height</strong> &ndash; The number of pixels that make up the vertical dimension of the emulated LCD display.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> hw.lcd.width </code></td>
    <td><strong>LCD pixel width</strong> &ndash; The number of pixels that make up the horizontal dimension of the emulated LCD display.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> hw.mainKeys </code></td>
    <td><strong>Hardware Back/Home keys</strong> &ndash; Determines whether the emulated device supports hardware Back and Home navigation buttons. You can set this value to <code>yes</code> if the buttons are implemented only in software. If <code>hw.mainKeys</code> is set to <code>yes</code>, the emulator will not display navigation buttons on the screen, but you can use the emulator side panel to "press" these buttons.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code> hw.ramSize </code></td>
    <td><strong>Device RAM Size</strong> &ndash; The amount of physical RAM on the emulated device, in megabytes. The default value will be computed from the screen size or the skin version. Increasing the size can provide faster emulator operation, but at the expense of demanding more resources from your development computer.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> hw.screen </code></td>
    <td><strong>Touch screen type</strong> &ndash; Defines the type of screen on the emulated device. A <code>multi-touch</code> screen can track two or more fingers on the touch interface. A <code>touch</code> screen can detect only single-finger touch events. A <code>no-touch</code> screen does not detect touch events.  </td>
    <td> touch, multi-touch, no-touch </td>
</tr>
<tr>
    <td><code> hw.sdCard </code></td>
    <td><strong>SDCard support</strong> &ndash; Determines whether the emulated device supports insertion and removal of virtual SD (Secure Digital) cards. The emulator uses mountable disk images stored on your development computer to simulate the partitions of actual SD card devices (see <code>hw.sdCard.path</code>).  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code> sdcard.size </code></td>
    <td><strong>SDCard size</strong> &ndash; Specifies the size of the virtual SD card file at the location specified by <code>hw.sdCard.path</code>. available on the device (in bytes). If the size is a simple integer, it specifies the size in bytes. You can also specify the size in kilobytes, megabytes, and gigabytes by appending K, M, or G to the size. The minimum size is 9M and the maximum size is 1023G.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> hw.sdCard.path </code></td>
    <td><strong>SDCard Image Path</strong> &ndash; Specifies the filename and path to an SD card partition image file on your development computer. For example, this path could be set to <strong>C:\sd\sdcard.img</strong> on Windows.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> hw.sensors.magnetic_field </code></td>
    <td><strong>Magnetic Field Sensor</strong> &ndash; Determines whether the emulated device supports a magnetic field sensor. The magnetic field sensor (also known as magnetometer) reports the ambient geomagnetic field as measured along three sensor axes. Enable this setting for apps that need access to a compass reading. For example, a navigation app might use this sensor to detect which direction the user faces.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code> hw.sensors.orientation </code></td>
    <td><strong>Orientation Sensor</strong> &ndash; Determines whether the emulated device provides orientation sensor values. The orientation sensor measures degrees of rotation that a device makes around all three physical axes (x, y, z). Note that the orientation sensor was deprecated as of Android 2.2 (API level 8).  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code> hw.sensors.proximity </code></td>
    <td><strong>Proximity Sensor</strong> &ndash; Determines whether the emulated device supports a proximity sensor. This sensor measures the proximity of an object relative to the view screen of a device. This sensor is typically used to determine whether a handset is being held up to a person's ear.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code> hw.sensors.temperature </code></td>
    <td><strong>Temperature Sensor</strong> &ndash; Determines whether the emulated device supports a temperature sensor. This sensor measures the temperature of the device in degrees Celsius (&deg;C).  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code> hw.touchScreen </code></td>
    <td><strong>Touch-screen support</strong> &ndash; Determines whether the emulated device supports a touch screen. The touch screen is used for direct manipulation of objects on the screen.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code> hw.trackBall </code></td>
    <td><strong>Trackball support</strong> &ndash; Determines whether the emulated device supports a trackball.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code> hw.useext4 </code></td>
    <td><strong>EXT4 file system support</strong> &ndash; Determines whether the emulated device uses the Linux EXT4 file system for partitions. Because the file system type is now auto-detected, this option is deprecated and ignored.  </td>
    <td> no </td>
</tr>
<tr>
    <td><code> kernel.newDeviceNaming </code></td>
    <td><strong>Kernel new device naming</strong> &ndash; Used to specify whether the kernel requires a new device naming scheme. This is typically used with Linux 3.10 kernels and later. If set to <code>autodetect</code>, the emulator will automatically detect whether the kernel requires a new device naming scheme.  </td>
    <td> autodetect, yes, no </td>
</tr>
<tr>
    <td><code> kernel.parameters </code></td>
    <td><strong>Kernel parameters</strong> &ndash; Specifies the string of Linux kernel boot parameters. By default, this setting is left blank.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> kernel.path </code></td>
    <td><strong>Kernel path</strong> &ndash; Specifies the path to the Linux kernel. If this path is not specified, the emulator looks in the emulator system directory for <code>kernel-ranchu</code>.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> kernel.supportsYaffs2 </code></td>
    <td><strong>YAFFS2 partition support</strong> &ndash; Determines whether the kernel supports YAFFS2 (Yet Another Flash File System 2) partitions. Typically, this applies only to kernels before Linux 3.10. If set to <code>autodetect</code> the emulator will automatically detect whether the kernel can mount YAFFS2 file systems.  </td>
    <td> autodetect, yes, no </td>
</tr>
<tr>
    <td><code> skin.name </code></td>
    <td><strong>Skin name</strong> &ndash; The name for an Android emulator skin. A skin is a collection of files that defines the visual and control elements of an emulator display; it describes what the window of the AVD will look like on your development computer. A skin describes screen size, buttons, and the overall design, but it does not affect the operation of your app. </td>
    <td> </td>
</tr>
<tr>
    <td><code> skin.path </code></td>
    <td><strong>Skin path</strong> &ndash; Path to the directory that contains the emulator skin files specified in <code>skin.name</code> This directory contains <code>hardware.ini</code> layout files, and image files for the display elements of the skin. </td>
    <td> </td>
</tr>
<tr>
    <td><code> skin.dynamic </code></td>
    <td><strong>Skin dynamic</strong> &ndash; Whether or not the skin is dynamic. The emulator skin is a dynamic skin if the emulator is to construct a skin of a given size based on a specified width and height. </td>
    <td> no </td>
</tr>
</table>
